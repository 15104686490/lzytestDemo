XmlBeanDefinitionReader中读取xml配置文件的流程
1.使用ResourLoader将源文件路径转换为对应的resource文件
2.通过DocumentLoader进行转换  转换为Document文件
3.对Document进行解析
loadBeanDefinitions方法 ：
获取xml文件的验证
加载xml文件 得到对应的document
根据返回的document注册bean
dtd和xsd
dtd一种xml约束模式语言 验证机制 保证格式正确有效
xsd xml schema描述了xml文档的结构 可以指定一个xml schema来验证某个xml文档  检查是否符合要求

entityResolver
作用是项目本身可以提供一个如何寻找dtd声明的方法 即由程序来实现寻找dtd声明的过程

doRegisterBeanDefinitions root
进行解析
profile解析
parseBeanDefinitions 读取xml
调用不同的方法进行处理
默认的命名空间 parseDefaultElement进行解析
针对不同的标签进行处理
对bean标签的处理
1.首先使用BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析
得到的BeanDefinitionHolder类型中包含配置文件中的属性
  1.解析提取id  name等属性
  创建承载各种属性的实例 classLoader不为空 则使用以传入的loader同一虚拟机加载对象 否则只是记录className
  解析各种属性 parseBeanDefinitionAttributes对element所有的元素属性进行解析
  解析子元素meta 额外的声明
  解析子元素lookup-method 获取器注入 一种特殊的方法注入 把一个方法声明为返回某种类型的bean 但实际要返回的bean是在配置文件中配置的
  获取要修饰的方法 并重写
  解析子元素replaced-method 方法替换 可以在运行时用新的方法替换现有的方法 而且还能动态的更改原有方法的逻辑 提取并进行记录
  解析子元素constructor-arg 构造函数解析
    解析Constructor-arg
  解析子元素property parsePropertyElement方法  提取后使用propertyValue进行封装  记录在实例的propertyValues中
  解析子元素qualifier 通过注入bean的名称来消除歧义
  注册解析的BeanDefinition 完成解析  装饰等工作后进行注册  注册到BeanDefinitionRegistry类型实例中 此处分为两部分
  通过BeanName注册和通过别名注册
  BeanName注册 即将其放入map中使用BeanName作为key
   对AbstractBeanDefinition的校验 methodOverrides属性校验
   对beanName已注册情况的处理 若不允许bean的覆盖 则抛出异常 否则直接覆盖
   加入map缓存
   清楚解析前留下的beanName缓存
  使用别名进行注册
   别名和BeanName相同的情况的处理 相同的情况删除别名
   覆盖处理 若别名已经使用并指向其他的beanName的处理
   alias循环jiancha
   注册alias
  2.进一步解析其他所有属性并同一封装至GenericBeanDefinition类型实例中
  3.如果检测到bean没有指定beanName 就使用默认规则生成name
  4.将获取到的信息封装到BeanDefinitionHolder的实例中
2.判断不为空后 需要对自定义标签进行解析
3.对解析完成后的bdHolder进行注册 使用BeanDefinitionReaderUtils的registerBeanDefinition方法
4.最后发出响应时间通知相关的监听器 这个bean已经加载完成了
  fireComponentRegistered

alias提供多个名称 可以使用alias标签来指定
import
导入模块的配置文件
 1.获取resource属性所表示的路径
 2.解析路径中系统属性，格式如${user.dir}
 3.判定location是绝对路径还是相对路径
 4.如果是绝对路径则地柜调用bean的解析过程 进行另一次的解析
 6.通知监听器 解析完成
嵌入式beans的解析
 调用地柜beans的解析过程
自定义采用custom

自定义标签的解析
自定义标签的使用

bean加载
spring加载bean的过程
1.转换对应的beanName
去除factoryBean的修饰符 取别名指定的最终的BeanName
2.尝试从缓存中加载单例bean
单例在同一个容器内只会加载一次 后续再获取bean 直接从单例缓存中获取了
若不成功在从singletonFactories中加载
3.bean实例化
缓存你中取到的时原始bean状态 并不是最终的bean 需要从指定的factory-method方法中返回bean
代码中getObjectForBeanInstance就是完成这个工作的
4.原型模式的依赖检查
循环依赖？
5.检测parentBeanFactory
如果没有缓存需要转到父类工厂去加载
6.将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition
7.寻找依赖
初始化过程中很可能会用到某些属性  而这些属性是动态配置的 并且配置成依赖于其他bean的 此时需要加载依赖的bean
8.针对不同的scope进行加载
根据配置执行不同的初始化策略
9.类型转换
程序到这里返回bean后基本已经结束了 根据设置的参数requiredType进行格式的转换

FactoryBean的使用
一般情况下spring通过反射机制 利用bean的class属性指定的实现类来实例化bean
