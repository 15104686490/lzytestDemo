XmlBeanDefinitionReader中读取xml配置文件的流程
1.使用ResourLoader将源文件路径转换为对应的resource文件
2.通过DocumentLoader进行转换  转换为Document文件
3.对Document进行解析
loadBeanDefinitions方法 ：
获取xml文件的验证
加载xml文件 得到对应的document
根据返回的document注册bean
dtd和xsd
dtd一种xml约束模式语言 验证机制 保证格式正确有效
xsd xml schema描述了xml文档的结构 可以指定一个xml schema来验证某个xml文档  检查是否符合要求

entityResolver
作用是项目本身可以提供一个如何寻找dtd声明的方法 即由程序来实现寻找dtd声明的过程

doRegisterBeanDefinitions root
进行解析
profile解析
parseBeanDefinitions 读取xml
调用不同的方法进行处理
默认的命名空间 parseDefaultElement进行解析
针对不同的标签进行处理
对bean标签的处理
1.首先使用BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析
得到的BeanDefinitionHolder类型中包含配置文件中的属性
  1.解析提取id  name等属性
  创建承载各种属性的实例 classLoader不为空 则使用以传入的loader同一虚拟机加载对象 否则只是记录className
  解析各种属性 parseBeanDefinitionAttributes对element所有的元素属性进行解析
  解析子元素meta 额外的声明
  解析子元素lookup-method 获取器注入 一种特殊的方法注入 把一个方法声明为返回某种类型的bean 但实际要返回的bean是在配置文件中配置的
  获取要修饰的方法 并重写
  解析子元素replaced-method 方法替换 可以在运行时用新的方法替换现有的方法 而且还能动态的更改原有方法的逻辑 提取并进行记录
  解析子元素constructor-arg 构造函数解析
    解析Constructor-arg
  解析子元素property parsePropertyElement方法  提取后使用propertyValue进行封装  记录在实例的propertyValues中
  解析子元素qualifier 通过注入bean的名称来消除歧义
  注册解析的BeanDefinition 完成解析  装饰等工作后进行注册  注册到BeanDefinitionRegistry类型实例中 此处分为两部分
  通过BeanName注册和通过别名注册
  BeanName注册 即将其放入map中使用BeanName作为key
   对AbstractBeanDefinition的校验 methodOverrides属性校验
   对beanName已注册情况的处理 若不允许bean的覆盖 则抛出异常 否则直接覆盖
   加入map缓存
   清楚解析前留下的beanName缓存
  使用别名进行注册
   别名和BeanName相同的情况的处理 相同的情况删除别名
   覆盖处理 若别名已经使用并指向其他的beanName的处理
   alias循环jiancha
   注册alias
  2.进一步解析其他所有属性并同一封装至GenericBeanDefinition类型实例中
  3.如果检测到bean没有指定beanName 就使用默认规则生成name
  4.将获取到的信息封装到BeanDefinitionHolder的实例中
2.判断不为空后 需要对自定义标签进行解析
3.对解析完成后的bdHolder进行注册 使用BeanDefinitionReaderUtils的registerBeanDefinition方法
4.最后发出响应时间通知相关的监听器 这个bean已经加载完成了
  fireComponentRegistered

alias提供多个名称 可以使用alias标签来指定
import
导入模块的配置文件
 1.获取resource属性所表示的路径
 2.解析路径中系统属性，格式如${user.dir}
 3.判定location是绝对路径还是相对路径
 4.如果是绝对路径则地柜调用bean的解析过程 进行另一次的解析
 6.通知监听器 解析完成
嵌入式beans的解析
 调用地柜beans的解析过程
自定义采用custom

自定义标签的解析
自定义标签的使用

bean加载
spring加载bean的过程
1.转换对应的beanName
去除factoryBean的修饰符 取别名指定的最终的BeanName
2.尝试从缓存中加载单例bean
单例在同一个容器内只会加载一次 后续再获取bean 直接从单例缓存中获取了
若不成功在从singletonFactories中加载
3.bean实例化
缓存你中取到的时原始bean状态 并不是最终的bean 需要从指定的factory-method方法中返回bean
代码中getObjectForBeanInstance就是完成这个工作的
4.原型模式的依赖检查
循环依赖？
5.检测parentBeanFactory
如果没有缓存需要转到父类工厂去加载
6.将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition
7.寻找依赖
初始化过程中很可能会用到某些属性  而这些属性是动态配置的 并且配置成依赖于其他bean的 此时需要加载依赖的bean
8.针对不同的scope进行加载
根据配置执行不同的初始化策略
9.类型转换
程序到这里返回bean后基本已经结束了 根据设置的参数requiredType进行格式的转换

FactoryBean的使用
一般情况下spring通过反射机制 利用bean的class属性指定的实现类来实例化bean
BeanFactory接口中定义的三个方法
getObject 有factory创建bean实例 若isSinglrton返回为true则将实例放到spring容器中但实例缓存池中
isSingleton 检查是否为单例
getObjectType 返回创建的bean类型

缓存中获取单例bean
不同的map存储不同类型的bean
singletonObjects 存储BeanName和bean实例 间的映射
singletonFactories 用于保存BeanName和创建bean工厂间的 映射
earlySingletonObjects 同样保存BeanName和bean实例之间的关系 与前面不同 一个单例bean放在此处后 创建过程中 就可以通过getBean获取到
目的是检测循环引用
registeredSingletons 用来保存目前已经注册的Bean

从bean的实例中获取对象
对工厂bean进行处理 得到最终的对象
getObjectFromFactoryBean
1.验证FactoryBean正确性
2.对非FactoryBean不做任何出出力
3.对bean进行转换
4.将从Factory中解析bean的工作委托给getObjectFromFactoryBean

获取单例
主要洛基在ObjectFactory类型的实例中实现
前面的准备处理包括
1.检查缓存是否已经加载过
2.若没有加载 则记录beanName的正在加载状态
3.加载单例记录加载状态
beforeSingletonCreation 记录加载转台 将正要创建的bean记录在缓存中 便于对循环依赖进行检测
4.通过调用参数传入的ObjectFactory的个体Object实例化bean
5.加载单例后的处理方法调用 当加载结束后需要溢出缓存中对该bean的正在加载状态记录
6.将加载的结果缓存并删除bean过程中锁记录的各种辅助状态
7.返回处理结果

准备创建bean
具体步骤
1.根据设置的class属性或者根据className来解析Class
2.对override属性进行标记及验证

3.应用初始化前的后处理器 解析指定bean是否存在初始化前的短路操作

4.创建bean

循环依赖
概念
多个bean相互之间持有对方 且最终形成一个环  可能会导致内存溢出的情况
解决方式
1.构造器循环依赖
2.setter循环依赖
3.prototype范围的依赖处理

创建bean
doCreateBean
1.如果是单例则需要首先清楚缓存
2，实例化bean 将BeanDefinition转换为BeanWrapper
   如果存在工厂方法则使用工厂方法进行初始化
   多个构造函数的情况 根据参数锁定构造函数并进行初始化
   如果不存在工厂方法也不存在有参数的构造函数 则使用默认的构造函数进行bean实例化
3.MergedBeanDefinitionPostProcessor应用
   bean合并后处理 AutoWired注解通过此方法实现注入类型的预解析
4.依赖处理
5.属性填充 将所有属性填充至bean的实例中
6.循环依赖检查
7.注册DisposableBean 如果注册了destroy-method 这里需要注册以便于在销毁的时候调用
8.完成创建并返回
创建bean实例
createBeanIntance方法
1.如果RootBeanDefinition中存在factoryMethodName属性 过着在配置文件中配置了工厂方法 那么会尝试使用InstantiateUsingFactoryMethod
方法 根据配置来生成bean实例
2.可能存在多个构造函数的情况 但参数是不同的 据此判断使用哪一个构造函数进行实例化
此处利用缓存机制 如果解析过的直接取缓存 否则再次进行解析
 spring中的实例创建分为两种情况 一种是通用的实例化 另一种是带有参数的实例化
 autowireConstructor
 1.构造函数参数确定
    根据explicitArgs参数判断 用户指定
    缓存中获取 如果之前有分析过 缓存中会记录 则可以直接拿来用
    配置文件获取
 2.构造函数的确定
    根据参数的个数进行匹配
    需要先获取参数的名称 两种方式 通过注解的方式直接获取 另一种方式是使用spring中的工具类ParameterNameDiscover来获取
 3，根据确定的构造函数转换对应的参数类型
 4.构造函数不确定性验证
 5.根据实例化策略以及得到的构造函数及构造函数参数实例化Bean
instantiateBean
实例化策略
没有简单的使用反射
如果有需要覆盖或替换的方法 使用cglib进行动态代理 在创建的同事将动态方法织如到类中
若没有则直接反射

记录创建bean的ObjectFactory
isSingleton 判断是否为单例
isSingletonCurrentlyInCreation 创建状态 加载状态

属性注入
属性填充
populateBean方法的处理流程
1.InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用，
此函数可以控制程序是否继续进行属性填充
2.根据注入类型 根据名字或根据类型 name/type 提取依赖的bean 并同一存入PropertyValues中
3.应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法，
对属性获取完毕填充前对属性的再次处理 例如 RequiredAnnotationBeanPostProcessor类中
对属性的验证
4.将所有的PropertyValue中的属性填充至BeanWrapper中

autowireByName 根据Name进行注入
找出已经加载的bean 并递归实例化 进而加入到pvs中
autowireByType 根据类型
PropertyValue到此处已经完成了对所有注入属性的获取 但是获取的属性是以PropertyValue的形式存储的
还没有应用到已经实例化的bean中  具体的操作在applyPropertyValues中实施

Bean初始化
bean配置中有一个init-method属性
aware方法
主要的目的是执初始化调用或一些必要的工作
激活aware方法
提供了一些相关的接口 实现这些的bean在初始化后悔获取一些相应的资源
例如实现applicationContextAware的bean 初始化后会被注入applicationContext的实例

处理器的应用BeanPostProcessor

自定义的init方法
实现InitializingBean接口 并在afterPropertiesSet中实现自己的初始化业务逻辑

注册DisposableBean
destroy-method 、 注册后处理器DestructionAwareBeanPostProcessor

容器扩展功能
applicationContext 对于 BeanFactory的 扩展
两者都是用于加载bean但前者在包含后者全部功能的基础上 进行了扩展
支持多个配置文件以数组的形式同时传入
xml文件初始化步骤
1.初始化前的准备工作 对系统属性或者环境变量进行准备及验证
2.初始化BeanFactory进行xml文件读取 复用BeanFactory
3.对BeanFactory进行各种功能的填充
4.子类覆盖方法做额外的处理
5.激活各种BeanFactory处理器
6.注册拦截bean创建的bean处理器 这里只是注册 真正的调用实在getBean的时候
7.为上下文初始化Message源 对不同的消息体进行国际化的处理
8.初始化应用消息广播器 并放入applicationEventMulticaster bean中
9.留给子类来初始化其他的bean
10.在素有注册的bean中查找listener bean 注册到消息广播器中
11.初始化剩下的单实例 非惰性
12.完成刷新过程 通知声明周期处理器lifecycleProcessor刷新过程 同时发出ContextRefreshEvent通知别人

环境准备
prepareRefresh

加载BeanFactory
obtainFreshBeanFactory 获取BeanFactory
1.创建DefaultListableBeanFactory
2.指定序列化ID
3.定制BeanFactory
4.加载BeanDefinition
5.使用全局变量记录BeanFactory类实例

加载BeanDefinition

功能扩展
prepareBeanFactory

添加applicationContextAwareProcessor处理器

注册依赖


